# -*- coding: utf-8 -*-
"""BT40529.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yC_JHK0nw6yG7AONiuuR0mtsS6SDPsgc
"""



!pip install numpy pandas matplotlib seaborn ipywidgets scikit-learn

import pandas as pd  # Make sure pandas is imported

# Now you can read the CSV file
data = pd.read_csv("Crop_recommendation.csv")
print(data.head())  # This will print the first few rows of your data

#for manipulations
import numpy as np
import pandas as pd
#for data visualization
import matplotlib.pyplot as plt
import seaborn as sns
#for interactivity
from ipywidgets import interact
#Let's read the data set
data = pd.read_csv("Crop_recommendation.csv")
#Let's Check the shape of the dataset
print("Shape of the dataset: ", data.shape)
#Let's check the head of the dataset
data.head()
#Let's check if there is any missing value present in the dataset i.e data cleaning
#isnull() returns boolean value and sum() returns the count
data.isnull().sum()
#Let's check the unique crops present in this Dataset and their occurence
data['label'].value_counts()
#Let's check the unique crops present in this Dataset and their occurence
data['label'].value_counts()
#Let's check the summary statistics for each Factor
@interact
def summary(crops = list(data['label'].value_counts().index)):
    x = data[data['label'] == crops]
    print(" ")
    print("Statistics for Nitrogen")
    print("Minimum Nitrogen required : ", x['N'].min())
    print("Average Nitrogen required : ", x['N'].mean())
    print("Maximum Nitrogen required : ", x['N'].max())
    print(" ")
    print("Statistics for Phosphorus")
    print("Minimum Phosphorus required : ", x['P'].min())
    print("Average Phosphorus required : ", x['P'].mean())
    print("Maximum Phosphorus required : ", x['P'].max())
    print(" ")
    print("Statistics for Potassium")
    print("Minimum Potassium required : ", x['K'].min())
    print("Average Potassium required : ", x['K'].mean())
    print("Maximum Potassium required : ", x['K'].max())
    print(" ")
    print("Statistics for Temperature")
    print("Minimum Temperature required : {0:.2f}".format(x['temperature'].min()))
    print("Average Temperature required : {0:.2f}".format(x['temperature'].mean()))
    print("Maximum Temperature required : {0:.2f}".format(x['temperature'].max()))
    print(" ")
    print("Statistics for Humidity")
    print("Minimum Humidity required : {0:.2f}".format(x['humidity'].min()))
    print("Average Humidity required : {0:.2f}".format(x['humidity'].mean()))
    print("Maximum Humidity required : {0:.2f}".format(x['humidity'].max()))
    print(" ")
    print("Statistics for PH")
    print("Minimum PH required : {0:.2f}".format(x['ph'].min()))
    print("Average PH required : {0:.2f}".format(x['ph'].mean()))
    print("Maximum PH required : {0:.2f}".format(x['ph'].max()))
    print(" ")
    print("Statistics for Rainfall")
    print("Minimum Rainfall required : {0:.2f}".format(x['rainfall'].min()))
    print("Average Rainfall required : {0:.2f}".format(x['rainfall'].mean()))
    print("Maximum Rainfall required : {0:.2f}".format(x['rainfall'].max()))
#Let's check the summary statistics for each of the Crops
@interact
def compare(conditions = ['N', 'P', 'K', 'temperature', 'humidity', 'ph', 'rainfall']):
    # Properly indent the following lines inside the function
    print("Average value for", conditions, "is {0:.2f}".format(data[conditions].mean()))
    print(" ")

    print("Rice : {0:.2f}".format(data[(data['label'] == 'rice')][conditions].mean()))
    print("Black Grams : {0:.2f}".format(data[(data['label'] == 'blackgram')][conditions].mean()))
    print("Banana : {0:.2f}".format(data[(data['label'] == 'banana')][conditions].mean()))
    print("Jute : {0:.2f}".format(data[(data['label'] == 'jute')][conditions].mean()))
    print("Coconut : {0:.2f}".format(data[(data['label'] == 'coconut')][conditions].mean()))
    print("Apple : {0:.2f}".format(data[(data['label'] == 'apple')][conditions].mean()))
    print("Papaya : {0:.2f}".format(data[(data['label'] == 'papaya')][conditions].mean()))
    print("Muskmelon : {0:.2f}".format(data[(data['label'] == 'muskmelon')][conditions].mean()))
    print("Grapes : {0:.2f}".format(data[(data['label'] == 'grapes')][conditions].mean()))
    print("Watermelon : {0:.2f}".format(data[(data['label'] == 'watermelon')][conditions].mean()))
    print("Kidney Beans : {0:.2f}".format(data[(data['label'] == 'kidneybeans')][conditions].mean()))
    print("Mung Beans : {0:.2f}".format(data[(data['label'] == 'mungbean')][conditions].mean()))
    print("Oranges: {0:.2f}".format(data[(data['label'] == 'orange')][conditions].mean()))
    print("Chick Peas : {0:.2f}".format(data[(data['label'] == 'chickpea')][conditions].mean()))
    print("Lentils : {0:.2f}".format(data[(data['label'] == 'lentil')][conditions].mean()))
    print("Cotton : {0:.2f}".format(data[(data['label'] == 'cotton')][conditions].mean()))
    print("Maize : {0:.2f}".format(data[(data['label'] == 'maize')][conditions].mean()))
    print("Moth Beans : {0:.2f}".format(data[(data['label'] == 'mothbeans')][conditions].mean()))
    print("Pigeon Peas: {0:.2f}".format(data[(data['label'] == 'pigeonpeas')][conditions].mean()))
    print("Mango : {0:.2f}".format(data[(data['label'] == 'mango')][conditions].mean()))
    print("Pomegranate : {0:.2f}".format(data[(data['label'] == 'pomegranate')][conditions].mean()))
    print("Coffee : {0:.2f}".format(data[(data['label'] == 'coffee')][conditions].mean()))
@interact
def compare(conditions = ['N', 'P', 'K', 'temperature', 'humidity', 'ph', 'rainfall']):
  # Print crops requiring greater than average values for selected condition
    print("Crops which require greater than average", conditions, '\n')
    print(data[data[conditions] > data[conditions].mean()]['label'].unique())
    print(" ")

    # Print crops requiring less than or equal to average values for selected condition
    print("Crops which require equal to or smaller than average", conditions, '\n')
    print(data[data[conditions] <= data[conditions].mean()]['label'].unique())
plt.figure(figsize=(15,8))
plt.subplot(2, 4, 1)
sns.distplot(data['N'], color = 'lightgrey')
plt.xlabel("Ratio of Nitrogen", fontsize = 12)
plt.grid()
plt.subplot(2, 4, 2)
sns.distplot(data['P'], color = 'lightblue')
plt.xlabel("Ratio of Phosphorus", fontsize = 12)
plt.grid()
plt.subplot(2, 4, 3)
sns.distplot(data['K'], color = 'darkblue')
plt.xlabel("Ratio of Potassium", fontsize = 12)
plt.grid()
plt.subplot(2, 4, 4)
sns.distplot(data['temperature'], color = 'black')
plt.xlabel("Temperature", fontsize = 12)
plt.grid()
plt.subplot(2, 4, 5)
sns.distplot(data['rainfall'], color = 'grey')
plt.xlabel("Rainfall", fontsize = 12)
plt.grid()
plt.subplot(2, 4, 6)
sns.distplot(data['humidity'], color = 'lightgreen')
plt.xlabel("Humidity", fontsize = 12)
plt.grid()
plt.subplot(2, 4, 7)
sns.distplot(data['ph'], color = 'darkgreen')
plt.xlabel("PH Level", fontsize = 12)
plt.grid()
plt.suptitle("Distribution for Agricultural Conditions", fontsize = 20)
plt.show()
# Some Interseting Patterns
print("Crops which requires very High rainfall:",data[data['rainfall'] > 200]['label'].unique())
print("Crops which requires very Low rainfall:",data[data['rainfall'] < 40]['label'].unique())
print("Crops which requires very High ratio of Nitrogen Content in soil :",data[data['N'] >
120]['label'].unique())
print("Crops which requires very High ratio of Phosphorous Content in soil :",data[data['P'] >
100]['label'].unique())
print("Crops which requires very High ratio of Potassium Content in soil :",data[data['K'] >
200]['label'].unique())
print("Crops which requires very High Rainfall :",data[data['rainfall'] > 200]['label'].unique())
print("Crops which requires very Low Rainfall:",data[data['rainfall'] < 40]['label'].unique())
print("Crops which requires very Low Temperature :",data[data['temperature'] <
10]['label'].unique())
print("Crops which requires very High Temperature :",data[data['temperature'] >
40]['label'].unique())
print("Crops which requires very Low Humidity :",data[data['humidity'] < 20]['label'].unique())
print("Crops which requires very Low pH :",data[data['ph'] < 4]['label'].unique())
print("Crops which requires very High pH :",data[data['ph'] > 8]['label'].unique())
# By using dataset, Find the best suitable Crop for Summer Season,Winter Season and Rainy
print("Summer Crops")
print(data[(data['temperature'] > 30) & (data['humidity'] > 50)]['label'].unique())
print(" ")
print("Winter Crops")
print(data[(data['temperature'] < 20) & (data['humidity'] > 30)]['label'].unique())
print(" ")
print("Rainy Crops")
print(data[(data['rainfall'] > 200) & (data['humidity'] > 30)]['label'].unique())
from sklearn.cluster import KMeans
#Removing the Labels column
x = data.drop(['label'], axis=1)
#Selecting all values of data
x = x.values
#Checking the shape
print(x.shape)
#Determining Optimum number of Clusters within Dataset by using K-means Clustering
plt.rcParams['figure.figsize'] = (10,4)
wcss = []
for i in range(1, 11):
    km = KMeans(n_clusters=i, init='k-means++', max_iter=300, n_init=10, random_state=0)
    km.fit(x)  # Fit the model
    wcss.append(km.inertia_)  # Append the value of inertia (sum of squared distances) to wcss

# Plotting the Elbow method graph
plt.plot(range(1, 11), wcss)
plt.title('The Elbow Method', fontsize=20)
plt.xlabel('No. of Clusters', fontsize=12)
plt.ylabel('WCSS (Within-Cluster Sum of Squares)', fontsize=12)
plt.show()
#Implementing K-means Algorithm to perform Clustering Analysis
km = KMeans(n_clusters = 4,init = 'k-means++',max_iter = 300, n_init = 10, random_state = 0)
y_means = km.fit_predict(x)
#Letsfind out results
a = data['label']
y_means = pd.DataFrame(y_means)
z = pd.concat([y_means, a],axis = 1)
z = z.rename(columns = {0: 'cluster'})
#Checking Clusters of Each crop
print("Checking results after applying K-means Clustering Analysis \n")
print("Crops in First Cluster:", z[z['cluster'] == 0]['label'].unique())
print(" ")
print("Crops in Second Cluster:", z[z['cluster'] == 1]['label'].unique())
print(" ")
print("Crops in Third Cluster:", z[z['cluster'] == 2]['label'].unique())
print(" ")
print("Crops in Forth Cluster:", z[z['cluster'] == 3]['label'].unique())
#Splitting dataset for Predictive Modelling
y = data['label']
x = data.drop(['label'],axis = 1)
print("Shape of x:", x.shape)
print("Shape of y:", y.shape)
#Training and Testing Sets for Validation of Results
from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test = train_test_split(x,y,test_size = 0.2,random_state = 0)
print("The shape of x train:", x_train.shape)
print("The shape of x test:", x_test.shape)
print("The shape of y train:", y_train.shape)
print("The shape of y test:", y_test.shape)
#Creating a Predictive model
from sklearn.linear_model import LogisticRegression
model = LogisticRegression()
model.fit(x_train, y_train)
y_pred = model.predict(x_test)
#Evaluating the Model Performance
from sklearn.metrics import confusion_matrix
#Evaluating Model Performance by using confusion matrix
plt.rcParams['figure.figsize'] = [10,10]
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot = True, cmap = 'Wistia')
plt.title('Confusion Matrix for Logistic Regression', fontsize=15)
plt.show()
from sklearn.metrics import classification_report
#Printing Classification Report
cr = classification_report(y_test, y_pred)
print(cr)
# Our model is ready,now we use model to predict Crop name
data.head()
prediction = model.predict((np.array([[90,
40,
40,
20,
80,
7,
200]])))
print("The suggested Crop for Given Climatic condition is :", prediction)